get_CIF <- function(cox.focus, cox.other, X){
fit <- tryCatch({survfit(cox.focus, newdata = X, se.fit = FALSE)},
error = handle_error)
Ht <- fit$cumhaz[fit$n.event>=1,]
if(is.null(dim(Ht))) return()
hi <- apply(Ht, 2, function(x) diff(c(0, x)))
for(cox.model in cox.other){
fit_other <- tryCatch({survfit(cox.model, newdata = X, se.fit = FALSE)},
error = handle_error)
Ht_other <- fit_other$cumhaz[fit$n.event>=1,]
Ht <- Ht + Ht_other
if(is.null(dim(Ht))) return()
}
CIF <- apply(exp(-Ht) * hi, 2, cumsum)
return(list(y = fit$time[fit$n.event>=1], CIF = CIF))
}
#######################################################################
# Internal helper function: calculate CIF based on AFT models
#######################################################################
get_CIF_aft <- function(ftime, fstatus, aft.focus, aft.other, newX = NULL){
if(is.null(newX)) newX <- aft.focus$x[,-1]
lambda <- exp(-aft.focus$coefficients[1]/aft.focus$scale)
alpha <- 1/aft.focus$scale
rs1 <- (-newX %*% aft.focus$coefficients[-1]) %>% exp
if(aft.focus$dist %in% c("weibull", "exponential")){
hi <- sapply(sort(ftime) %>% unique,
function(x) rs1 * lambda * alpha * (rs1 * x)^(alpha-1)) %>% t
Ht <- sapply(sort(ftime) %>% unique,
function(x) lambda * (rs1 * x)^(alpha)) %>% t
}else if(aft.focus$dist == "lognormal"){
St <- sapply(sort(ftime) %>% unique,
function(x){1 - pnorm((log(x) -
as.matrix(cbind(1, newX)) %*%
aft.focus$coefficients)/
aft.focus$scale)}) %>% t
fx <- sapply(sort(ftime) %>% unique,
function(x){exp(-1/2*((log(x)-
as.matrix(cbind(1, newX)) %*%
aft.focus$coefficients)/
aft.focus$scale)^2)/
(x*sqrt(2*pi)*aft.focus$scale)}) %>% t
hi <- fx / St
Ht <- - log(St)
}else if(aft.focus$dist == "loglogistic"){
hi <- sapply(sort(ftime) %>% unique,
function(x){(rs1 * lambda * alpha * (rs1 * x)^(alpha-1))/
(1 + lambda *(rs1 * x)^(alpha))}) %>% t
Ht <- sapply(sort(ftime) %>% unique,
function(x) -log(1/(1 + lambda * (rs1 * x)^(alpha)))) %>% t
}
for(aft.model in aft.other){
lambda <- exp(-aft.model$coefficients[1]/aft.model$scale)
alpha <- 1/aft.model$scale
rs2 <- (-newX %*% aft.model$coefficient[-1]) %>% exp
if(aft.model$dist %in% c("weibull", "exponential")){
Ht_other <- sapply(sort(ftime) %>% unique,
function(x) lambda * (rs2 * x)^(alpha)) %>% t
Ht <- Ht + Ht_other
}else if(aft.model$dist == "lognormal"){
St <- sapply(sort(ftime) %>% unique,
function(x){1 - pnorm((log(x) -
as.matrix(cbind(1, newX)) %*%
aft.model$coefficient)/
aft.model$scale)}) %>% t
Ht_other <- - log(St)
Ht <- Ht + Ht_other
}else if(aft.model$dist == "loglogistic"){
Ht_other <- sapply(sort(ftime) %>% unique,
function(x) -log(1/(1 + lambda * (rs2 * x)^(alpha)))) %>% t
Ht <- Ht + Ht_other
}
if(is.null(dim(Ht))) return()
}
temp.matrix <- rbind(rep(0, dim(Ht)[2]), exp(-Ht) * hi)
new_matrix <- (temp.matrix[-nrow(temp.matrix), ] + temp.matrix[-1, ]) / 2
new_matrix <- diff(c(0, sort(ftime) %>% unique)) * new_matrix
new_matrix <- apply(new_matrix, 2, cumsum)
return(list(y = sort(ftime) %>% unique, CIF = new_matrix))
}
# Load necessary libraries
library(cmprsk)
# Set sample size and event of interest
n <- 1000
event <- 1
# Simulate data for two competing risks using Fine-Gray model
final_data <- simulateTwoCauseFineGrayModel(n = n, v = 5,
beta1 = matrix(-c(1, 1)),#coef for event 1
beta2 = matrix(c(1, 1)),#coef for event 2
mu = 0, censor = 0.3, p = 0.5)
# number of each type of event
table(final_data$obs.event)
library(cmprsk)
z <- crr(final_data$obs.times, final_data$obs.event, final_data)
z.p <- predict(z, as.matrix(final_data[, -c(1,2)]))
#z.p <- predict(z, as.matrix(final_data))
tau <- quantile(final_data$obs.times, 0.9)
tau <- max(final_data$obs.times[which(final_data$obs.event==event &
final_data$obs.times<=tau)])
# Fit Fine-Gray model to full data (using cmprsk::crr)
fg_model <- crr(final_data$obs.times, final_data$obs.event, final_data)
# Define tau: restrict to 90th percentile of observed time for event of interest
tau <- quantile(final_data$obs.times, 0.9)
tau <- max(final_data$obs.times[which(final_data$obs.event==event &
final_data$obs.times<=tau)])
# Predict CIF using pam.predict_subject_cif() for Fine-Gray model
pred_cif_FineGray <- pam.predict_subject_cif(model1 = NULL, model2 = NULL, final_data = final_data, event.type = 1, tau = tau, num.grid = 1, fg_model = fg_model, cr_model = NULL)
# Fit cause-specific Cox models for both event types
cox.model1 <- coxph(Surv(final_data$obs.times, obs.event == 1) ~ ., data = final_data, x = TRUE)
cox.model2 <- coxph(Surv(final_data$obs.times, obs.event == 2) ~ ., data = final_data, x = TRUE)
# Predict CIF using cause-specific Cox models
pred_cif_cox <- pam.predict_subject_cif(
model1 = cox.model1, model2 = cox.model2,
final_data = final_data,
event.type = 1, tau = tau, num.grid = 1,
fg_model = NULL, cr_model = NULL
)
# Fit AFT models (Weibull distribution) for both event types
aft.model.w1 <- survreg(Surv(final_data$obs.times, obs.event == 1) ~ ., data = final_data, x = TRUE, dist = "weibull")
aft.model.w2 <- survreg(Surv(final_data$obs.times, obs.event == 2) ~ ., data = final_data, x = TRUE, dist = "weibull")
# Predict CIF using AFT models
pred_cif_aftw <- pam.predict_subject_cif(
model1 = aft.model.w1, model2 = aft.model.w2,
final_data = final_data,
event.type = 1, tau = tau, num.grid = 1,
fg_model = NULL, cr_model = NULL
)
pam.predicted_survial_eval_cr(
pred_cif = pred_cif_FineGray$m_pred[, -1],
event_time = final_data$obs.times,
time.cif = pred_cif_FineGray$m_pred[, 1],
status = final_data$obs.event,
metrics = "all",
t_star = NULL,
tau = tau,
event_type = 1
)
pam.predicted_survial_eval_cr(
pred_cif = pred_cif_FineGray$m_pred[, -1],
event_time = final_data$obs.times,
time.cif = pred_cif_FineGray$m_pred[, 1],
status = final_data$obs.event,
metrics = "all",
t_star = NULL,
tau = tau,
event_type = 1
pam.predicted_survial_eval_cr(
pred_cif = pred_cif_FineGray$m_pred[, -1],
event_time = final_data$obs.times,
time.cif = pred_cif_FineGray$m_pred[, 1],
status = final_data$obs.event,
metrics = "all",
t_star = NULL,
tau = tau,
event_type = 1)
pam.predicted_survial_eval_cr(
pred_cif = pred_cif_cox$m_pred[, -1],
event_time = final_data$obs.times,
time.cif = pred_cif_cox$m_pred[, 1],
status = final_data$obs.event,
metrics = "all",
t_star = NULL,
tau = tau,
event_type = 1
)
# Evaluate CIF prediction performance for AFT (Weibull) model
pam.predicted_survial_eval_cr(
pred_cif = pred_cif_aftw$m_pred[, -1],
event_time = final_data$obs.times,
time.cif = pred_cif_aftw$m_pred[, 1],
status = final_data$obs.event,
metrics = "all",
t_star = NULL,
tau = tau,
event_type = 1
)
setwd("/Users/wanghd/Desktop/Research/Survival Analysis/PAmeasures-master")
devtools::document()
rm(list = c("pam.predict_subject_cif", "simulateTwoCauseFineGrayModel"))
devtools::install("/Users/wanghd/Desktop/Research/Survival Analysis/PAmeasures-master")
devtools::document()
devtools::document()
devtools::install("/Users/wanghd/Desktop/Research/Survival Analysis/PAmeasures-master")
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
library(PAmeasures)
library ( riskCommunicator )
library ( dplyr )
library(tdROC)
set.seed(1234)
df <- framingham %>% filter(PERIOD==1) %>%
select(DEATH, TIMEDTH, HYPERTEN, TIMEHYP, RANDID, SEX:educ) %>%
group_by(RANDID) %>%
mutate(time = min(TIMEDTH, TIMEHYP),
status = ifelse(time==TIMEDTH, DEATH*2, HYPERTEN),
status = ifelse(status == 1, 1, 0)) %>% #
select(time, status, everything()) %>%
filter(time!=0) %>% ungroup() %>%
select(time, status, SEX:educ, -BPMEDS) %>% na.omit()
X <- df %>% select(SEX:educ)
df$status %>% table
# split train and test data
sample_index <- sample(1:dim(df)[1], round(2/3*dim(df)[1]), replace = F)
train_data <- df[sample_index, ]
column_names <- colnames(df)
covariates <-column_names[-(1:2)]
library(survival)
library(dplyr)
## 1. Build a full cohort from the built-in `pbc` data -----------------
data(pbc, package = "survival")
cohort <- pbc %>%
filter(!is.na(time)) %>%           # drop a few rows with missing
transmute(
id        = row_number(),
time      = time,
status    = as.numeric(status == 2),   # 1 = death
age       = age,
sex       = factor(sex, labels = c("Female", "Male")),
biomarker = log(bili)                  # bilirubin as a marker
)
set.seed(1)
eval_time <- median(cohort$time) # set evaluation time for brier and AUC
km_cens <- survfit(Surv(time, 1 - status) ~ 1, data = cohort) # get censoring distribution
### (a) Unstratified case-cohort (Prentice weights) ---------------------
subco_size <- 0.10                         # 10 % random sub-cohort
subcohort  <- sample(cohort$id, round(nrow(cohort) * subco_size))
cc_unstrat <- cohort %>%
mutate(subco = id %in% subcohort,       # TRUE = in sub-cohort
case  = status == 1)
#cc_unstrat$case_weights <- weighted_param(cc_unstrat$time, cc_unstrat$status, design    = "casecohort", subcohort = cc_unstrat$subco)
cc_unstrat$case_weights <- cc_weights(cc_unstrat$time, cc_unstrat$status, subcohort = cc_unstrat$subco)
cc_unstrat_an <- cc_unstrat %>% filter(subco | status == 1)
fit_cox_prentice <- coxph(
Surv(time, status) ~ age + sex + biomarker,
data    = cc_unstrat_an,
weights = case_weights,         # Prentice sampling weights
x = T, y = T
)
pam.coxph_restricted(fit_cox_prentice, predict = T) -> pred.results
pam.predicted_survial_eval_casecohort(analysis_data = cc_unstrat_an, pred_results = pred.results, eval_time = eval_time, km_cens_fit = km_cens, case_weights = cc_unstrat_an$case_weights, metrics = c("Harrell’s C", "Uno’s C", "Brier Score", "Time Dependent Auc"))
library(yardstick)
pam.predicted_survial_eval_casecohort(analysis_data = cc_unstrat_an, pred_results = pred.results, eval_time = eval_time, km_cens_fit = km_cens, case_weights = cc_unstrat_an$case_weights, metrics = c("Harrell’s C", "Uno’s C", "Brier Score", "Time Dependent Auc"))
rm(list = ls())
library(PAmeasures)
library ( riskCommunicator )
library ( dplyr )
library(tdROC)
library(survival)
library(dplyr)
## 1. Build a full cohort from the built-in `pbc` data -----------------
data(pbc, package = "survival")
cohort <- pbc %>%
filter(!is.na(time)) %>%           # drop a few rows with missing
transmute(
id        = row_number(),
time      = time,
status    = as.numeric(status == 2),   # 1 = death
age       = age,
sex       = factor(sex, labels = c("Female", "Male")),
biomarker = log(bili)                  # bilirubin as a marker
)
set.seed(1)
eval_time <- median(cohort$time) # set evaluation time for brier and AUC
km_cens <- survfit(Surv(time, 1 - status) ~ 1, data = cohort) # get censoring distribution
### (a) Unstratified case-cohort (Prentice weights) ---------------------
subco_size <- 0.10                         # 10 % random sub-cohort
subcohort  <- sample(cohort$id, round(nrow(cohort) * subco_size))
cc_unstrat <- cohort %>%
mutate(subco = id %in% subcohort,       # TRUE = in sub-cohort
case  = status == 1)
#cc_unstrat$case_weights <- weighted_param(cc_unstrat$time, cc_unstrat$status, design    = "casecohort", subcohort = cc_unstrat$subco)
cc_unstrat$case_weights <- cc_weights(cc_unstrat$time, cc_unstrat$status, subcohort = cc_unstrat$subco)
cc_unstrat_an <- cc_unstrat %>% filter(subco | status == 1)
fit_cox_prentice <- coxph(
Surv(time, status) ~ age + sex + biomarker,
data    = cc_unstrat_an,
weights = case_weights,         # Prentice sampling weights
x = T, y = T
)
pam.coxph_restricted(fit_cox_prentice, predict = T) -> pred.results
pam.predicted_survial_eval_casecohort(analysis_data = cc_unstrat_an, pred_results = pred.results, eval_time = eval_time, km_cens_fit = km_cens, case_weights = cc_unstrat_an$case_weights, metrics = c("Harrell’s C", "Uno’s C", "Brier Score", "Time Dependent Auc"))
rlang::last_trace()
library(dplyr)
pam.predicted_survial_eval_casecohort(analysis_data = cc_unstrat_an, pred_results = pred.results, eval_time = eval_time, km_cens_fit = km_cens, case_weights = cc_unstrat_an$case_weights, metrics = c("Harrell’s C", "Uno’s C", "Brier Score", "Time Dependent Auc"))
library(survival)
library(dplyr)
pam.predicted_survial_eval_casecohort(analysis_data = cc_unstrat_an, pred_results = pred.results, eval_time = eval_time, km_cens_fit = km_cens, case_weights = cc_unstrat_an$case_weights, metrics = c("Harrell’s C", "Uno’s C", "Brier Score", "Time Dependent Auc"))
pam.predicted_survial_eval_two_phase(analysis_data = cc_unstrat_an, pred_results = pred.results, eval_time = eval_time, km_cens_fit = km_cens, case_weights = cc_unstrat_an$case_weights, metrics = c("Harrell’s C", "Uno’s C", "Brier Score", "Time Dependent Auc"))
cc_unstrat$case_weights
pred.results
library(purrr)
pam.predicted_survial_eval_casecohort(analysis_data = cc_unstrat_an, pred_results = pred.results, eval_time = eval_time, km_cens_fit = km_cens, case_weights = cc_unstrat_an$case_weights, metrics = c("Harrell’s C", "Uno’s C", "Brier Score", "Time Dependent Auc"))
pam.predicted_survial_eval_two_phase(analysis_data = cc_unstrat_an, pred_results = pred.results, eval_time = eval_time, km_cens_fit = km_cens, case_weights = cc_unstrat_an$case_weights, metrics = c("Harrell’s C", "Uno’s C", "Brier Score", "Time Dependent Auc"))
pam.predicted_survial_eval_casecohort(analysis_data = cc_unstrat_an, pred_results = pred.results, eval_time = eval_time, km_cens_fit = km_cens, case_weights = cc_unstrat_an$case_weights, metrics = c("Harrell’s C", "Uno’s C", "Brier Score", "Time Dependent Auc"))
### (b) Stratified case-cohort (Borgan II) ------------------------------
# stratum = sex × above/below median age
age_med <- median(cohort$age, na.rm = TRUE)
cohort  <- cohort %>%
mutate(strata = interaction(sex, age > age_med, drop = TRUE))
# Allocate sub-cohort proportionally to cases in each stratum
cases_per_stratum <- table(cohort$strata[cohort$status == 1])
p_stratum         <- cases_per_stratum / sum(cases_per_stratum)
subco_strat <- unlist(Map(
function(st, p)
sample(cohort$id[cohort$strata == st], round(p * nrow(cohort) * subco_size)),
st = names(p_stratum), p = p_stratum
))
cc_strat <- cohort %>%
mutate(subco = id %in% subco_strat,
case  = status == 1)
# cc_strat$case_weights <- weighted_param(cc_strat$time, cc_strat$status, design = "strat_casecohort", strata= cc_strat$strata, subcohort  = cc_strat$subco)
cc_unstrat$case_weights <- cc_weights(cc_unstrat$time, cc_unstrat$status, subcohort = cc_unstrat$subco, strata = cc_strat$strata)
cc_strat_an <- cc_strat %>% filter(subco | status == 1)
#strata_levels <- levels(cc_strat$strata)
fit_borganII_cox <- coxph(
Surv(time, status) ~ age + sex + biomarker,
data    = cc_strat_an,
weights = case_weights,          # Borgan II sampling weights
x = T, y = T
)
### (b) Stratified case-cohort (Borgan II) ------------------------------
# stratum = sex × above/below median age
age_med <- median(cohort$age, na.rm = TRUE)
cohort  <- cohort %>%
mutate(strata = interaction(sex, age > age_med, drop = TRUE))
# Allocate sub-cohort proportionally to cases in each stratum
cases_per_stratum <- table(cohort$strata[cohort$status == 1])
p_stratum         <- cases_per_stratum / sum(cases_per_stratum)
subco_strat <- unlist(Map(
function(st, p)
sample(cohort$id[cohort$strata == st], round(p * nrow(cohort) * subco_size)),
st = names(p_stratum), p = p_stratum
))
cc_strat <- cohort %>%
mutate(subco = id %in% subco_strat,
case  = status == 1)
# cc_strat$case_weights <- weighted_param(cc_strat$time, cc_strat$status, design = "strat_casecohort", strata= cc_strat$strata, subcohort  = cc_strat$subco)
cc_strat$case_weights <- cc_weights(cc_unstrat$time, cc_unstrat$status, subcohort = cc_unstrat$subco, strata = cc_strat$strata)
cc_strat_an <- cc_strat %>% filter(subco | status == 1)
#strata_levels <- levels(cc_strat$strata)
fit_borganII_cox <- coxph(
Surv(time, status) ~ age + sex + biomarker,
data    = cc_strat_an,
weights = case_weights,          # Borgan II sampling weights
x = T, y = T
)
### (b) Stratified case-cohort (Borgan II) ------------------------------
# stratum = sex × above/below median age
age_med <- median(cohort$age, na.rm = TRUE)
cohort  <- cohort %>%
mutate(strata = interaction(sex, age > age_med, drop = TRUE))
# Allocate sub-cohort proportionally to cases in each stratum
cases_per_stratum <- table(cohort$strata[cohort$status == 1])
p_stratum         <- cases_per_stratum / sum(cases_per_stratum)
subco_strat <- unlist(Map(
function(st, p)
sample(cohort$id[cohort$strata == st], round(p * nrow(cohort) * subco_size)),
st = names(p_stratum), p = p_stratum
))
cc_strat <- cohort %>%
mutate(subco = id %in% subco_strat,
case  = status == 1)
# cc_strat$case_weights <- weighted_param(cc_strat$time, cc_strat$status, design = "strat_casecohort", strata= cc_strat$strata, subcohort  = cc_strat$subco)
cc_strat$case_weights <- cc_weights(cc_strat$time, cc_strat$status, subcohort = cc_strat$subco, strata = cc_strat$strata)
cc_strat_an <- cc_strat %>% filter(subco | status == 1)
#strata_levels <- levels(cc_strat$strata)
fit_borganII_cox <- coxph(
Surv(time, status) ~ age + sex + biomarker,
data    = cc_strat_an,
weights = case_weights,          # Borgan II sampling weights
x = T, y = T
)
pam.coxph_restricted(fit_borganII_cox, predict = T) -> pred.results
## ---------- evaluate  -----------------------------------
pam.predicted_survial_eval_casecohort(analysis_data = cc_strat_an, pred_results = pred.results, eval_time = eval_time, km_cens_fit = km_cens, case_weights = cc_strat_an$case_weights, metrics = c("Harrell’s C", "Uno’s C", "Brier Score", "Time Dependent Auc"))
## ─────────────────────────────────────────────────────────────
## (d)  2 : 1  SEX-MATCHED nested case-control sample
## ─────────────────────────────────────────────────────────────
k   <- 2          # controls per case
eps <- 1e-4       # fake-interval width  ( > 0 )
case_rows  <- which(cohort$status == 1)      # indices of all cases
ctrl_idx   <- integer()                     # to collect controls
set_vec    <- integer()                     # parallel vector → set_id
for (idx in case_rows) {
t_fail <- cohort$time[idx]
sx     <- cohort$sex[idx]
risk <- which(cohort$time >= t_fail &      # still at risk
cohort$sex  == sx  &         # same sex  (matching var)
cohort$id   != cohort$id[idx])
if (length(risk) < k) next                 # skip if not enough ctrls
sel        <- sample(risk, k)
ctrl_idx   <- c(ctrl_idx, sel)
set_vec    <- c(set_vec, rep(cohort$id[idx], k))
}
## ---------- build NCC data-frame --------------------------------------
ncc_match <- dplyr::bind_rows(
cohort[case_rows, ]  %>%  dplyr::mutate(set_id = id),   # cases
cohort[ctrl_idx,  ] %>%  dplyr::mutate(set_id = set_vec)
) %>%
dplyr::arrange(set_id)
## ---------- risk-set size  R_j  & weight  w_j  ------------------------
ncc_match <- ncc_match %>%
dplyr::group_by(set_id) %>%
dplyr::mutate(
R_j      = sum(cohort$time >= dplyr::first(time) &      # size of
cohort$sex  == dplyr::first(sex)),       # matching stratum
w        = R_j / (k + 1),                               # (k+1 = 3)
case_t   = dplyr::first(time),                          # case’s fail time
tstart   = case_t - eps,                                # fake interval
tstop    = case_t
) %>%
dplyr::ungroup()
## Cox counting-process formulation
fit_match_cox <- coxph(
Surv(tstart, tstop, status) ~ age + biomarker +
strata(set_id) + offset(log(w)),
data = ncc_match, x = T, y = T
)
pam.coxph_restricted(fit_match_cox, predict = T) -> pred.results
## ---------- evaluate  -----------------------------------
ncc_match$case_weights <- ncc_weights(ncc_match$time, ncc_match$status,
design = "matched_ncc",
m      = k,
strata = ncc_match$sex) -> w # note here we need to specify the strata
## ─────────────────────────────────────────────────────────────
## (d)  2 : 1  SEX-MATCHED nested case-control sample
## ─────────────────────────────────────────────────────────────
k   <- 2          # controls per case
eps <- 1e-4       # fake-interval width  ( > 0 )
case_rows  <- which(cohort$status == 1)      # indices of all cases
ctrl_idx   <- integer()                     # to collect controls
set_vec    <- integer()                     # parallel vector → set_id
for (idx in case_rows) {
t_fail <- cohort$time[idx]
sx     <- cohort$sex[idx]
risk <- which(cohort$time >= t_fail &      # still at risk
cohort$sex  == sx  &         # same sex  (matching var)
cohort$id   != cohort$id[idx])
if (length(risk) < k) next                 # skip if not enough ctrls
sel        <- sample(risk, k)
ctrl_idx   <- c(ctrl_idx, sel)
set_vec    <- c(set_vec, rep(cohort$id[idx], k))
}
## ---------- build NCC data-frame --------------------------------------
ncc_match <- dplyr::bind_rows(
cohort[case_rows, ]  %>%  dplyr::mutate(set_id = id),   # cases
cohort[ctrl_idx,  ] %>%  dplyr::mutate(set_id = set_vec)
) %>%
dplyr::arrange(set_id)
## ---------- risk-set size  R_j  & weight  w_j  ------------------------
ncc_match <- ncc_match %>%
dplyr::group_by(set_id) %>%
dplyr::mutate(
R_j      = sum(cohort$time >= dplyr::first(time) &      # size of
cohort$sex  == dplyr::first(sex)),       # matching stratum
w        = R_j / (k + 1),                               # (k+1 = 3)
case_t   = dplyr::first(time),                          # case’s fail time
tstart   = case_t - eps,                                # fake interval
tstop    = case_t
) %>%
dplyr::ungroup()
## Cox counting-process formulation
fit_match_cox <- coxph(
Surv(tstart, tstop, status) ~ age + biomarker +
strata(set_id) + offset(log(w)),
data = ncc_match, x = T, y = T
)
pam.coxph_restricted(fit_match_cox, predict = T) -> pred.results
## ---------- evaluate  -----------------------------------
ncc_match$case_weights <- ncc_weights(ncc_match$time, ncc_match$status,
m      = k,
strata = ncc_match$sex) -> w # note here we need to specify the strata
pam.predicted_survial_eval_ncc(analysis_data = ncc_match, pred_results = pred.results, eval_time = eval_time, km_cens_fit = km_cens, case_weights = ncc_match$case_weights, metrics = c("Harrell’s C", "Uno’s C", "Brier Score", "Time Dependent Auc"))
### (c) Unmatched nested case-control (2:1) -----------------------------
k <- 2            # number of CONTROLS per case  (2 : 1 design)
eps <- 1e-4       # width of the “fake” entry interval for coxph()
case_rows     <- which(cohort$status == 1)          # rows of all cases
case_ids      <- cohort$id[case_rows]
ctrl_indices  <- integer(0)                         # will collect controls
set_id_vector <- integer(0)                         # parallel vector → set_id
for (idx in case_rows) {
t_fail  <- cohort$time[idx]
riskset <- which(cohort$time >= t_fail & cohort$id != cohort$id[idx])
if (length(riskset) < k) next                     # skip if too few controls
sel <- sample(riskset, k)
ctrl_indices  <- c(ctrl_indices, sel)
set_id_vector <- c(set_id_vector, rep(cohort$id[idx], k))
}
## ---------- build NCC data-frame  ------------------------------------
ncc_unmatch <- bind_rows(
cohort[case_rows, ]           %>% mutate(set_id = id),      # cases
cohort[ctrl_indices, ]        %>% mutate(set_id = set_id_vector) )
# ensure all controls/cases for one set are contiguous (helps readability)
ncc_unmatch <- ncc_unmatch %>% arrange(set_id)
## ---------- compute R_j and w_j  -------------------------------------
ncc_unmatch <- ncc_unmatch %>%               # add R_j per set
group_by(set_id) %>%                       # each set = one case + k ctrls
mutate(R_j = sum(cohort$time >= first(time)),   # first(time) = t_fail of case
k_plus_1 = k + 1,
w = R_j / k_plus_1,
case_time = first(time),
tstart = case_time - eps,
tstop  = case_time)                      # fake interval for coxph()
## fit model
fit_ncc_unmatch <- coxph(Surv(tstart, tstop, status) ~ age + sex + biomarker +
offset(log(w)),
data = ncc_unmatch, x = T, y = T)
pam.coxph_restricted(fit_ncc_unmatch, predict = T) -> pred.results
## ---------- evaluate  -----------------------------------
# ncc_unmatch$case_weights <- weighted_param(ncc_unmatch$time, ncc_unmatch$status, design = "ncc", m = k)
ncc_unmatch$case_weights <- ncc_weights(ncc_unmatch$time, ncc_unmatch$status, m = k)
ncc_unmatch <- ncc_unmatch %>% ungroup()
pam.predicted_survial_eval_ncc(analysis_data = ncc_unmatch, pred_results = pred.results, eval_time = eval_time, km_cens_fit = km_cens, case_weights = ncc_unmatch$case_weights, metrics = c("Harrell’s C", "Uno’s C", "Brier Score", "Time Dependent Auc"))
